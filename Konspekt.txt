(микро-конспект)
*********
lesson 02
*********

clone - создание локальной копии git-репозитория (выполняется единоразово);
commit - сохранить изменения в локальном репозитории;
push - отправляет изменения на удаленный git-репозиторий;
pull - скачка последней версии с удаленного git-репозитория;

*********
lesson 03
*********

discard - удалить все неотправленные в локальный репозиторий изменения
revert - откатить существующие локальные комиты
hard reset - удалить несколько последних комитов в локальный репозиторий

*********
lesson 04
*********

Порядок работы при ветвлении:
1. Создаем "новую ветку", пишем код.
2. Тестируем "новую ветку".
3. Мерджим "мастер" в "новую ветку".
4. Тестируем как работает "новая ветка" с "мастером".
5. Мерджим "новую ветку" в "мастер".
6. Удаляем "новую ветку" т.к. она больше не нужна.

*********
lesson 05
*********

конфликты, пути решения:
1.Abort Merge - отмена слияния
2.Дабл клик на коммите - открывается ConflictSolver. Самостоятельно принимаем
решение - как должен выглядеть коммит. Редактируем. Сейваем. Коммитим.
3.Переход в Мастер, Мерж с соседней ветки - никаких конфликтов.
4.Пуш
5.Удаляем соседнюю ветку с локального и удаленного репозитория.

*********
lesson 06
*********

Ошибка 1. Боязнь создания новых веток.
Правильно - создавать новые ветки для добавления в программу новых функций, по
завершению их разработки Merge новую функцию в основную программу.
Ошибка 2. Добавлять в репозиторий "бинарники" (.exe-файлы, откомпилированную программу).
Правильно - пользоваться функцией Ignore (то есть не комитить выбранные файлы/папки).
Нажать Ignore нужных файлов и выполнить Commit для файла .gitignore.

*********
lesson 07
*********

Ошибка 3. При создании новой ветки удалять файлы основной программы перенесенные
 в новую ветку. При последующем слиянии новой ветки с основной программой эти
  файлы будут удалены из основной программы.
Правильно - оставлять все файлы основной программы в новой ветке, даже если для
 этой фичи они и не нужны.
 Ошибка 4. Коммитить сразу большие изменения (например,
  работал целый день или больше), особенно если изменения относятся к совершенно
   разным частям проекта.
Правильно - для разных логических изменений (разных файлов, функций и т.п.) - разные коммиты.
Плюсы:
+ В коментарии к мелкому коммиту легче адекватно описать изменения
+ Можно откатить одно изменение, не затрагивая другого
Ошибка 5. Если при написании новой фичи что-то подправили в основной программе,
перейти в основную ветку и продублировать изменения. В таком случае при слиянии
 веток может выйти конфликт (можно в одной из версий допустить ошибку).
Правильно - использовать Cherry-pick. То есть подтянуть только нужный коммит из
новой фичи в основную программу, не сливая ветки полностью. Или, как я понял,
можно всё-таки продублировать изменения в обоих ветках вручную, но только
 копипастом (внести изменения в ветке фичи - скопировать файл вообще в другое
  место - Check out ветку основной программы - заменить файл). Если изменения
  будут абсолютно идентичны, то при слиянии веток конфликта не будет.
Но лучше всё-таки пользоваться Cherry-pick. В логах Гита автоматически будет
понятно, что изменялось в программе.

Микро-конспект
1. Для каждого изменения делать новую ветку, которую по завершению сливать в мастер.
2. Не нужно комитить скомпилированные файлы (использовать команду Ignore).
3. При создании "новой ветки" не нужно удалять файлы "мастера" перенесенные в
"новую ветку", т.к. при последующем слиянии "новой ветки" с "мастером" эти файлы
 будут удалены из "мастера".
4. Избегать больших коммитов. Для разных логических изменений (разных файлов) - 
разные комиты.
+ В коментарии к мелкому коммиту легче описать изменения
+ По коммитам можно откатить изменения
5. Использовать Cherry-pick - позволяет подтянуть только тот комит (Log)
что нужен не сливая ветки полностью. Супер фича !

*********
lesson 08
*********



*********
lesson 09
*********



*********
lesson 10
*********
